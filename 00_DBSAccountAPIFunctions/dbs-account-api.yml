AWSTemplateFormatVersion: 2010-09-09
Description: Custom resources wrapping the Databricks Account API

#-------------------------------------------------------------------------
Parameters:

  ResourceOwner:
    Description: The value of the Owner tag in the created resources on AWS
    Type: String

  ExistingRoleArnForLambda:
    Description: The ARN of an existing role for the custom resource Lambda functions
    Type: String
    Default: ''

  IamRoleExtraTag1Key:
    Description: Key of the 1st optional extra tag for the Lambda execution IAM role
    Type: String
    Default: ''
  IamRoleExtraTag1Value:
    Description: Value of the 1st optional extra tag for the Lambda execution IAM role
    Type: String
    Default: ''

  IamRoleExtraTag2Key:
    Description: Key of the 2nd optional extra tag for the Lambda execution IAM role
    Type: String
    Default: ''
  IamRoleExtraTag2Value:
    Description: Value of the 2nd optional extra tag for the Lambda execution IAM role
    Type: String
    Default: ''

  IamRoleExtraTag3Key:
    Description: Key of the 3rd optional extra tag for the Lambda execution IAM role
    Type: String
    Default: ''
  IamRoleExtraTag3Value:
    Description: Value of the 3rd optional extra tag for the Lambda execution IAM role
    Type: String
    Default: ''

  IamRoleExtraTag4Key:
    Description: Key of the 4th optional extra tag for the Lambda execution IAM role
    Type: String
    Default: ''
  IamRoleExtraTag4Value:
    Description: Value of the 4th optional extra tag for the Lambda execution IAM role
    Type: String
    Default: ''

#-------------------------------------------------------------------------
Conditions:

  CreateRoleForLambda:
    !Equals [!Ref ExistingRoleArnForLambda, ""]

  CreateOptionalIAMTag1:
    !And [!Not [!Equals [!Ref IamRoleExtraTag1Key, ""] ], !Not [!Equals [!Ref IamRoleExtraTag1Value, ""] ] ]

  CreateOptionalIAMTag2:
    !And [!Not [!Equals [!Ref IamRoleExtraTag2Key, ""] ], !Not [!Equals [!Ref IamRoleExtraTag2Value, ""] ] ]

  CreateOptionalIAMTag3:
    !And [!Not [!Equals [!Ref IamRoleExtraTag3Key, ""] ], !Not [!Equals [!Ref IamRoleExtraTag3Value, ""] ] ]

  CreateOptionalIAMTag4:
    !And [!Not [!Equals [!Ref IamRoleExtraTag4Key, ""] ], !Not [!Equals [!Ref IamRoleExtraTag4Value, ""] ] ]

#-------------------------------------------------------------------------
Mappings:

  DatabricksAddresses:
    us-east-1:
      "workspace": "com.amazonaws.vpce.us-east-1.vpce-svc-09143d1e626de2f04"
      "backend": "com.amazonaws.vpce.us-east-1.vpce-svc-00018a8c3ff62ffdf"
      "webapp": "nvirginia.cloud.databricks.com"
      "sccrelay": "tunnel.us-east-1.cloud.databricks.com"
      "rds": "mdb7sywh50xhpr.chkweekm4xjq.us-east-1.rds.amazonaws.com"
      "controlplane": "3.237.73.224/28"
    us-east-2:
      "workspace": "com.amazonaws.vpce.us-east-2.vpce-svc-041dc2b4d7796b8d3"
      "backend": "com.amazonaws.vpce.us-east-2.vpce-svc-090a8fab0d73e39a6"
      "webapp": "ohio.cloud.databricks.com"
      "sccrelay": "tunnel.us-east-2.cloud.databricks.com"
      "rds": "md7wf1g369xf22.cluz8hwxjhb6.us-east-2.rds.amazonaws.com"
      "controlplane": "3.128.237.208/28"
    us-west-1:
      "workspace": "UNSUPPORTED"
      "backend": "UNSUPPORTED"
      "webapp": "oregon.cloud.databricks.com"
      "sccrelay": "tunnel.cloud.databricks.com"
      "rds": "mdzsbtnvk0rnce.c13weuwubexq.us-west-1.rds.amazonaws.com"
      "controlplane": "44.234.192.32/28"
    us-west-2:
      "workspace": "com.amazonaws.vpce.us-west-2.vpce-svc-0129f463fcfbc46c5"
      "backend": "com.amazonaws.vpce.us-west-2.vpce-svc-0158114c0c730c3bb"
      "webapp": "oregon.cloud.databricks.com"
      "sccrelay": "tunnel.cloud.databricks.com"
      "rds": "mdpartyyphlhsp.caj77bnxuhme.us-west-2.rds.amazonaws.com"
      "controlplane": "44.234.192.32/28"
    eu-west-1:
      "workspace": "com.amazonaws.vpce.eu-west-1.vpce-svc-0da6ebf1461278016"
      "backend": "com.amazonaws.vpce.eu-west-1.vpce-svc-09b4eb2bc775f4e8c"
      "webapp": "ireland.cloud.databricks.com"
      "sccrelay": "tunnel.eu-west-1.cloud.databricks.com"
      "rds": "md15cf9e1wmjgny.cxg30ia2wqgj.eu-west-1.rds.amazonaws.com"
      "controlplane": "3.250.244.112/28"
    eu-west-2:
      "workspace": "com.amazonaws.vpce.eu-west-2.vpce-svc-01148c7cdc1d1326c"
      "backend": "com.amazonaws.vpce.eu-west-2.vpce-svc-05279412bf5353a45"
      "webapp": "london.cloud.databricks.com"
      "sccrelay": "tunnel.eu-west-2.cloud.databricks.com"
      "rds": "mdio2468d9025m.c6fvhwk6cqca.eu-west-2.rds.amazonaws.com"
      "controlplane": "18.134.65.240/28"
    eu-central-1:
      "workspace": "com.amazonaws.vpce.eu-central-1.vpce-svc-081f78503812597f7"
      "backend": "com.amazonaws.vpce.eu-central-1.vpce-svc-08e5dfca9572c85c4"
      "webapp": "frankfurt.cloud.databricks.com"
      "sccrelay": "tunnel.eu-central-1.cloud.databricks.com"
      "rds": "mdv2llxgl8lou0.ceptxxgorjrc.eu-central-1.rds.amazonaws.com"
      "controlplane": "18.159.44.32/28"
    ap-southeast-1:
      "workspace": "com.amazonaws.vpce.ap-southeast-1.vpce-svc-02535b257fc253ff4"
      "backend": "com.amazonaws.vpce.ap-southeast-1.vpce-svc-0557367c6fc1a0c5c"
      "webapp": "singapore.cloud.databricks.com"
      "sccrelay": "tunnel.ap-southeast-1.cloud.databricks.com"
      "rds": "md1n4trqmokgnhr.csnrqwqko4ho.ap-southeast-1.rds.amazonaws.com"
      "controlplane": "13.214.1.96/28"
    ap-southeast-2:
      "workspace": "com.amazonaws.vpce.ap-southeast-2.vpce-svc-0b87155ddd6954974"
      "backend": "com.amazonaws.vpce.ap-southeast-2.vpce-svc-0b4a72e8f825495f6"
      "webapp": "sydney.cloud.databricks.com"
      "sccrelay": "tunnel.ap-southeast-2.cloud.databricks.com"
      "rds": "mdnrak3rme5y1c.c5f38tyb1fdu.ap-southeast-2.rds.amazonaws.com"
      "controlplane": "3.26.4.0/28"
    ap-northeast-1:
      "workspace": "com.amazonaws.vpce.ap-northeast-1.vpce-svc-02691fd610d24fd64"
      "backend": "com.amazonaws.vpce.ap-northeast-1.vpce-svc-02aa633bda3edbec0"
      "webapp": "tokyo.cloud.databricks.com"
      "sccrelay": "tunnel.ap-northeast-1.cloud.databricks.com"
      "rds": "mddx5a4bpbpm05.cfrfsun7mryq.ap-northeast-1.rds.amazonaws.com"
      "controlplane": "35.72.28.0/28"
    ap-south-1:
      "workspace": "com.amazonaws.vpce.ap-south-1.vpce-svc-0dbfe5d9ee18d6411"
      "backend": "com.amazonaws.vpce.ap-south-1.vpce-svc-03fd4d9b61414f3de"
      "webapp": "mumbai.cloud.databricks.com"
      "sccrelay": "tunnel.ap-south-1.cloud.databricks.com"
      "rds": "mdjanpojt83v6j.c5jml0fhgver.ap-south-1.rds.amazonaws.com"
      "controlplane": "65.0.37.64/28"
    ca-central-1:
      "workspace": "com.amazonaws.vpce.ca-central-1.vpce-svc-0205f197ec0e28d65"
      "backend": "com.amazonaws.vpce.ca-central-1.vpce-svc-0c4e25bdbcbfbb684"
      "webapp": "canada.cloud.databricks.com"
      "sccrelay": "tunnel.ca-central-1.cloud.databricks.com"
      "rds": "md1w81rjeh9i4n5.co1tih5pqdrl.ca-central-1.rds.amazonaws.com"
      "controlplane": "3.96.84.208/28"

#-------------------------------------------------------------------------
Resources:

  # Role for functions
  BaseLambdaRole:
    Condition: CreateRoleForLambda
    Type: AWS::IAM::Role
    Properties: 
      RoleName: !Sub ${AWS::StackName}-CustomResourceFunctionRole
      Description: Basic execution role for the CloudFormation custom resource Lambda functions using the Databricks Account API
      AssumeRolePolicyDocument:
        Version: 2012-10-17
        Statement:
          - Effect: Allow
            Principal:
              Service:
              - lambda.amazonaws.com
            Action:
              - sts:AssumeRole
      Policies:
        - PolicyName: !Sub ${AWS::StackName}-CustomResourceFunctionRolePolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Sid: AllowWritingToLogs
                Effect: Allow
                Action:
                  - logs:CreateLogGroup
                  - logs:CreateLogStream
                  - logs:PutLogEvents
                Resource:
                  - arn:aws:logs:*:*:log-group:/aws/lambda/*:log-stream:*
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
        - !If
          - CreateOptionalIAMTag1
          - Key: !Ref IamRoleExtraTag1Key
            Value: !Ref IamRoleExtraTag1Value
          - !Ref AWS::NoValue
        - !If
          - CreateOptionalIAMTag2
          - Key: !Ref IamRoleExtraTag2Key
            Value: !Ref IamRoleExtraTag2Value
          - !Ref AWS::NoValue
        - !If
          - CreateOptionalIAMTag3
          - Key: !Ref IamRoleExtraTag3Key
            Value: !Ref IamRoleExtraTag3Value
          - !Ref AWS::NoValue
        - !If
          - CreateOptionalIAMTag4
          - Key: !Ref IamRoleExtraTag4Key
            Value: !Ref IamRoleExtraTag4Value
          - !Ref AWS::NoValue

  # Databricks Addresses
  DatabricksAddressesFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-DatabricksAddresses
      Description: The custom resource function to retrieve the public addresses of Databricks in the region
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile:  !Sub 
          - |
            import cfnresponse, socket
            def lambda_handler(event, context):
              attributes = {} if event['RequestType'] == 'Delete' else {"Workspace": "${workspace}", "Backend": "${backend}", "Webapp" : "${webapp}", "SCCRelay" : "${sccrelay}", "Metastore" : "${rds}", "MetastoreIP" : socket.gethostbyname("${rds}"), "ControlPlane" : "${controlplane}"}
              cfnresponse.send(event, context, cfnresponse.SUCCESS, attributes)
          - webapp: !FindInMap [DatabricksAddresses, !Ref AWS::Region, webapp]
            sccrelay: !FindInMap [DatabricksAddresses, !Ref AWS::Region, sccrelay]
            rds: !FindInMap [DatabricksAddresses, !Ref AWS::Region, rds]
            controlplane: !FindInMap [DatabricksAddresses, !Ref AWS::Region, controlplane]
            workspace: !FindInMap [DatabricksAddresses, !Ref AWS::Region, workspace]
            backend: !FindInMap [DatabricksAddresses, !Ref AWS::Region, backend]
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  DatabricksAddressesLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${DatabricksAddressesFn}
      RetentionInDays: 365


  # Credentials configuration
  CredentialsConfigurationFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-CredentialsConfiguration
      Description: The custom resource function to create a credentials configuration
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile: |
          import cfnresponse, urllib3, json
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            if event['RequestType'] == 'Update': # No updates are supported
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              return
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] == 'Create':
              for propertName in ('CrossAccountRoleArn', 'CredentialsName'):
                if checkForMissingProperty(event['ResourceProperties'], propertName): return
              postData = {
                "credentials_name": event['ResourceProperties']['CredentialsName'],
                "aws_credentials": { "sts_role": { "role_arn": event['ResourceProperties']['CrossAccountRoleArn'] } }
              }
              response = http.request('POST', accountsAPIBaseURL + '/credentials', headers=myHeaders, body = json.dumps(postData))
              if response.status != 201:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
              else:
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, json.loads(response.data.decode())['credentials_id'])
            else: # 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/credentials/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  CredentialsConfigurationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${CredentialsConfigurationFn}
      RetentionInDays: 365


  # Storage configuration
  StorageConfigurationFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-StorageConfiguration
      Description: The custom resource function to create a storage configuration
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile: |
          import cfnresponse, urllib3, json
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            if event['RequestType'] == 'Update': # No updates are supported
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              return
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] == 'Create':
              for propertName in ('RootBucket', 'StorageName'):
                if checkForMissingProperty(event['ResourceProperties'], propertName): return
              postData = {
                "storage_configuration_name": event['ResourceProperties']['StorageName'],
                "root_bucket_info": { "bucket_name": event['ResourceProperties']['RootBucket'] }
              }
              response = http.request('POST', accountsAPIBaseURL + '/storage-configurations', headers=myHeaders, body = json.dumps(postData))
              if response.status != 201:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
              else:
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, json.loads(response.data.decode())['storage_configuration_id'])
            else: # 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/storage-configurations/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  StorageConfigurationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${StorageConfigurationFn}
      RetentionInDays: 365


  ### The VPC Endpoint for the Databricks AWS PrivateLink
  VpcEnpointFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-VpcEnpoint
      Description: The custom resource function to create a Databricks VPC endpoint
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 600
      Code:
        ZipFile: !Sub |
            import cfnresponse, urllib3, json
            region = "${AWS::Region}"
            def checkForMissingProperty(properties, propertyName):
              if propertyName not in properties:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
                return True
              return False
            def lambda_handler(event, context):
              if event['RequestType'] == 'Update': # No updates are supported
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                return
              for propertName in ('DatabricksAccountId', 'Username', 'Password'):
                if checkForMissingProperty(event['ResourceProperties'], propertName): return
              accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
              myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
              http = urllib3.PoolManager()
              if event['RequestType'] == 'Create':
                for propertName in ('EndpointName', 'VpcEndpointId'):
                  if checkForMissingProperty(event['ResourceProperties'], propertName): return
                postData = {"vpc_endpoint_name": event['ResourceProperties']['EndpointName'], "aws_vpc_endpoint_id": event['ResourceProperties']['VpcEndpointId'], "region": region}
                response = http.request('POST', accountsAPIBaseURL + '/vpc-endpoints', headers=myHeaders, body = json.dumps(postData))
                if response.status != 201:
                  errorMessage = 'Unknown Error'
                  try: errorMessage = json.loads(response.data.decode())['message']
                  except: errorMessage = response.reason
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                  return
                dbsVpcEndpointId = json.loads(response.data.decode())['vpc_endpoint_id']
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, dbsVpcEndpointId)
              else: # 'Delete':
                response = http.request('DELETE', accountsAPIBaseURL + '/vpc-endpoints/' + event['PhysicalResourceId'], headers=myHeaders)
                if response.status != 200:
                  errorMessage = 'Unknown Error'
                  try: errorMessage = json.loads(response.data.decode())['message']
                  except: errorMessage = response.reason
                  print(errorMessage)
                cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
  VpcEnpointLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${VpcEnpointFn}
      RetentionInDays: 365


  ### The network configuration
  NetworkConfigurationFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-NetworkConfiguration
      Description: The custom resource function to create a network configuration
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile: |
          import cfnresponse, urllib3, json
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] == 'Create':
              if 'NetworkName' not in event['ResourceProperties']:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No NetworkName property specified")
                return
              if 'VpcId' not in event['ResourceProperties']:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No VpcId property specified")
                return
              if ('Subnets' not in event['ResourceProperties']) or type(event['ResourceProperties']['Subnets']) != list:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No Subnets property specified")
                return
              if ('SecurityGroups' not in event['ResourceProperties']) or type(event['ResourceProperties']['SecurityGroups']) != list:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No SecurityGroups property specified")
                return
              postData = {
                "network_name": event['ResourceProperties']['NetworkName'],
                "vpc_id": event['ResourceProperties']['VpcId'],
                "subnet_ids": event['ResourceProperties']['Subnets'],
                "security_group_ids": event['ResourceProperties']['SecurityGroups']
              }
              if ('VpcEndpoints' in event['ResourceProperties']) and (type(event['ResourceProperties']) == dict) and \
                ('RestApiEndpointId' in event['ResourceProperties']['VpcEndpoints']) and ('DataplaneRelayEndpointId' in event['ResourceProperties']['VpcEndpoints']) and \
                (event['ResourceProperties']['VpcEndpoints']['RestApiEndpointId'] is not None) and (len(event['ResourceProperties']['VpcEndpoints']['RestApiEndpointId']) > 0) and \
                (event['ResourceProperties']['VpcEndpoints']['DataplaneRelayEndpointId'] is not None) and (len(event['ResourceProperties']['VpcEndpoints']['DataplaneRelayEndpointId']) > 0):
                postData["vpc_endpoints"] = { "rest_api": [ event['ResourceProperties']['VpcEndpoints']['RestApiEndpointId'] ], "dataplane_relay": [ event['ResourceProperties']['VpcEndpoints']['DataplaneRelayEndpointId'] ] }
              response = http.request('POST', accountsAPIBaseURL + '/networks', headers=myHeaders, body = json.dumps(postData))
              if response.status != 201:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                return
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, json.loads(response.data.decode())['network_id'])
              return
            if event['RequestType'] == 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/networks/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  NetworkConfigurationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${NetworkConfigurationFn}
      RetentionInDays: 365


  ### The private access configuration
  PrivateAccessConfigurationFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-PrivateAccessConfiguration
      Description: The custom resource function to create a private access configuration for a Databricks workspace
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile: !Sub |
          import cfnresponse, urllib3, json
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] in ('Create', 'Update'):
              for propertName in ('PrivateAccessSettingsName', 'PublicAccessEnabled', 'AllowedVpcEndpoints'):
                if checkForMissingProperty(event['ResourceProperties'], propertName): return
              postData = {
                "private_access_settings_name": event['ResourceProperties']['PrivateAccessSettingsName'],
                "region": "${AWS::Region}",
                "public_access_enabled": event['ResourceProperties']['PublicAccessEnabled'],
                "private_access_level": "ENDPOINT",
                "allowed_vpc_endpoint_ids": event['ResourceProperties']['AllowedVpcEndpoints']
              }
              response = None
              if event['RequestType'] == 'Create':
                response = http.request('POST', accountsAPIBaseURL + '/private-access-settings', headers=myHeaders, body = json.dumps(postData))
              else:
                response = http.request('PUT', accountsAPIBaseURL + '/private-access-settings/' + event['PhysicalResourceId'], headers=myHeaders, body = json.dumps(postData))
              if response.status not in (200, 201):
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                return
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, json.loads(response.data.decode())['private_access_settings_id'])
              return
            if event['RequestType'] == 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/private-access-settings/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  PrivateAccessConfigurationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${PrivateAccessConfigurationFn}
      RetentionInDays: 365


  ### The managed keys configuration
  ManagedKeysConfigurationFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-ManagedKeysConfiguration
      Description: The custom resource function to create a customer managed keys configuration
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile: |
          import cfnresponse, urllib3, json
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] == 'Create':
              if 'KeyArn' not in event['ResourceProperties']:
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No KeyArn property specified")
                return
              if ('UseCases' not in event['ResourceProperties']) or (type(event['ResourceProperties']['UseCases']) != list):
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No UseCases property specified")
                return
              postData = {
                "aws_key_info": { "key_arn": event['ResourceProperties']['KeyArn'] },
                "use_cases": event['ResourceProperties']['UseCases']
              }
              if 'KeyAlias' in event['ResourceProperties']:
                postData['aws_key_info']['key_alias'] = event['ResourceProperties']['KeyAlias']
              if 'ReuseKeyForClusterVolumes' in event['ResourceProperties']:
                postData['aws_key_info']['reuse_key_for_cluster_volumes'] = event['ResourceProperties']['ReuseKeyForClusterVolumes']
              response = http.request('POST', accountsAPIBaseURL + '/customer-managed-keys', headers=myHeaders, body = json.dumps(postData))
              if response.status != 201:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                return
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, json.loads(response.data.decode())['customer_managed_key_id'])
              return
            if event['RequestType'] == 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/customer-managed-keys/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
            cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  ManagedKeysConfigurationLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${ManagedKeysConfigurationFn}
      RetentionInDays: 365


  ### The workspace object
  WorkspaceFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-Workspace
      Description: The custom resource function to create a Databricks workspace
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 900
      Code:
        ZipFile: !Sub |
          import cfnresponse, urllib3, json, time
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            if event['RequestType'] in ('Create', 'Update'):
              for propertName in ('WorkspaceName', 'CredentialsId', 'StorageId', 'NetworkId'):
                if checkForMissingProperty(event['ResourceProperties'], propertName): return
              postData = {
                "credentials_id": event['ResourceProperties']['CredentialsId'],
                "network_id": event['ResourceProperties']['NetworkId']
              }
              if ('StorageKeyId' in event['ResourceProperties']) and (event['ResourceProperties']['StorageKeyId'] is not None) and (len(event['ResourceProperties']['StorageKeyId']) > 0):
                postData["storage_customer_managed_key_id"] = event['ResourceProperties']['StorageKeyId']
              if event['RequestType'] == 'Create':
                postData["workspace_name"] = event['ResourceProperties']['WorkspaceName']
                postData["aws_region"] = "${AWS::Region}"
                postData["storage_configuration_id"] = event['ResourceProperties']['StorageId']
                if ('ManagedServicesKeyId' in event['ResourceProperties']) and (event['ResourceProperties']['ManagedServicesKeyId'] is not None) and (len(event['ResourceProperties']['ManagedServicesKeyId']) > 0):
                  postData["managed_services_customer_managed_key_id"] = event['ResourceProperties']['ManagedServicesKeyId']
                if ('PrivateAccessId' in event['ResourceProperties']) and (event['ResourceProperties']['PrivateAccessId'] is not None) and (len(event['ResourceProperties']['PrivateAccessId']) > 0):
                  postData["private_access_settings_id"] = event['ResourceProperties']['PrivateAccessId']
              response = None
              if event['RequestType'] == 'Create':
                response = http.request('POST', accountsAPIBaseURL + '/workspaces', headers=myHeaders, body = json.dumps(postData))
              else:
                response = http.request('PATCH', accountsAPIBaseURL + '/workspaces/' + event['PhysicalResourceId'], headers=myHeaders, body = json.dumps(postData))
              if response.status not in (200, 201):
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                return
              workspaceObject = json.loads(response.data.decode())
              workspaceId = str(workspaceObject['workspace_id'])
              deploymentName = workspaceObject['deployment_name']
              while True:
                time.sleep(5)
                try:
                  response = http.request('GET', accountsAPIBaseURL + '/workspaces/' + workspaceId, headers=myHeaders)
                  if json.loads(response.data.decode())['workspace_status'] == 'RUNNING': break
                except Exception as e:
                  print(str(e))
                  break
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {'DeploymentName': deploymentName}, workspaceId)
            else: # 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/workspaces/' + event['PhysicalResourceId'], headers=myHeaders)
              if response.status != 200:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  WorkspaceLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${WorkspaceFn}
      RetentionInDays: 365

  ### The Unity Catalog Metastore object
  UCMetastoreFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-UCMetastore
      Description: The custom resource function to create a Databricks Unity Catalog metastore
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 100
      Code:
        ZipFile: !Sub |
          import cfnresponse, urllib3, json, time
          def checkForMissingProperty(properties, propertyName):
            if propertyName not in properties:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            for propertName in ('DatabricksAccountId', 'Username', 'Password'):
              if checkForMissingProperty(event['ResourceProperties'], propertName): return
            accountsAPIBaseURL = 'https://accounts.cloud.databricks.com/api/2.0/accounts/' + event['ResourceProperties']['DatabricksAccountId']
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json'}
            http = urllib3.PoolManager()
            metastoreId = None if event['RequestType'] == 'Create' else event['PhysicalResourceId']
            if event['RequestType'] in ('Create', 'Update'):
              for propertName in ('Name', 'Bucket', 'StorageCredentialsRole'):
                if checkForMissingProperty(event['ResourceProperties'], propertName): return
              postData = {"name": event['ResourceProperties']['Name'],"storage_root": "s3://" + event['ResourceProperties']['Bucket'],"region":"${AWS::Region}"}
              if event['RequestType'] == 'Create':
                response = http.request('POST', accountsAPIBaseURL + '/metastores', headers=myHeaders, body = json.dumps(postData))
                if int(response.status / 100) != 2:
                  errorMessage = 'Unknown Error'
                  try: errorMessage = json.loads(response.data.decode())['message']
                  except: errorMessage = response.reason
                  cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                  return
                metastoreId = json.loads(response.data.decode())["metastore_id"]
              dataAccessConfigurationInput = {
                  "metastore_id": metastoreId, "name": metastoreId + "-data-access-config-" + str(int(time.time())),
                  "aws_iam_role": {"role_arn": event['ResourceProperties']['StorageCredentialsRole']}, "is_default": True
              }
              response = http.request('POST', accountsAPIBaseURL + '/metastores/' + metastoreId + '/data-access-configurations', headers=myHeaders, body = json.dumps(dataAccessConfigurationInput))
              if int(response.status / 100) != 2:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                res = http.request('DELETE', accountsAPIBaseURL + '/metastores/' + metastoreId + "?force=true", headers=myHeaders)
                if int(res.status / 100) != 2:
                  errorMessage = 'Unknown Error'
                  try: errorMessage = json.loads(res.data.decode())['message']
                  except: errorMessage = res.reason
                  print(errorMessage)
                return
              dataAccessConfigId = json.loads(response.data.decode())["id"]
              metastoreInfoInput = {"storage_root_credential_id": dataAccessConfigId}
              if 'DeltaSharingTokenLifetimeSeconds' in event['ResourceProperties']:
                metastoreInfoInput["delta_sharing_recipient_token_lifetime_in_seconds"] = int(event['ResourceProperties']['DeltaSharingTokenLifetimeSeconds'])
                metastoreInfoInput["delta_sharing_scope"] = "INTERNAL_AND_EXTERNAL"
                if 'DeltaSharingOrganisationName' in event['ResourceProperties']: metastoreInfoInput["delta_sharing_organization_name"] = event['ResourceProperties']['DeltaSharingOrganisationName']
              response = http.request('PATCH', accountsAPIBaseURL + '/metastores/' + metastoreId, headers=myHeaders, body = json.dumps(metastoreInfoInput))
              if int(response.status / 100) != 2:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
                res = http.request('DELETE', accountsAPIBaseURL + '/metastores/' + metastoreId + "?force=true", headers=myHeaders)
                if int(res.status / 100) != 2:
                  errorMessage = 'Unknown Error'
                  try: errorMessage = json.loads(res.data.decode())['message']
                  except: errorMessage = res.reason
                  print(errorMessage)
                return
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, metastoreId)
            else: # 'Delete':
              response = http.request('DELETE', accountsAPIBaseURL + '/metastores/' + metastoreId + "?force=true", headers=myHeaders)
              if int(response.status / 100) != 2:
                errorMessage = 'Unknown Error'
                try: errorMessage = json.loads(response.data.decode())['message']
                except: errorMessage = response.reason
                print(errorMessage)
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  UCMetastoreLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/lambda/${UCMetastoreFn}
      RetentionInDays: 365

  # The function for attaching the Unity Catalog Metastore on the workspace
  UCMetastoreAssignmentFn:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub ${AWS::StackName}-MetastoreAssignment
      Description: The custom resource function to assign a workspace to a metastore
      Handler: index.lambda_handler
      MemorySize: 256
      Role: !If [CreateRoleForLambda, !GetAtt BaseLambdaRole.Arn, !Ref ExistingRoleArnForLambda]
      Runtime: python3.9
      Timeout: 25
      Code:
        ZipFile: |
          import cfnresponse, urllib3, json
          def checkForMissingProperty(event, propertyName):
            if propertyName not in event['ResourceProperties']:
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = "No " + propertyName + " property specified")
              return True
            return False
          def lambda_handler(event, context):
            if event['RequestType'] != 'Create':
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
              return
            for propertyName in ('DatabricksAccountId', 'Username', 'Password', 'MetastoreId', 'WorkspaceId', 'WorkspaceDeploymentName'):
              if checkForMissingProperty(event, propertyName): return
            http = urllib3.PoolManager()
            myHeaders = urllib3.util.make_headers(basic_auth = event['ResourceProperties']['Username'] + ':' + event['ResourceProperties']['Password']) | {'Content-Type': 'application/json', 'Accept': 'application/json'}
            metastoreAssignmentURL = 'https://' + event['ResourceProperties']['WorkspaceDeploymentName'] + '.cloud.databricks.com/api/2.0/unity-catalog/workspaces/' + event['ResourceProperties']['WorkspaceId'] + '/metastore'
            putData = { "metastore_id": event['ResourceProperties']['MetastoreId'], "default_catalog_name": "hive_metastore" }
            response = http.request('PUT', metastoreAssignmentURL, headers=myHeaders, body = json.dumps(putData))
            if int(response.status / 100) != 2:
              errorMessage = 'Unknown Error'
              try: errorMessage = json.loads(response.data.decode())['message']
              except: errorMessage = response.reason
              cfnresponse.send(event, context, cfnresponse.FAILED, {}, reason = errorMessage)
            else:
              cfnresponse.send(event, context, cfnresponse.SUCCESS, {}, event['ResourceProperties']['MetastoreId'])
      Tags:
        - Key: Owner
          Value: !Ref ResourceOwner
  # The log group for this function
  UCMetastoreAssignmentGroup:
    Type: AWS::Logs::LogGroup
    DeletionPolicy: Retain
    UpdateReplacePolicy: Retain
    Properties:
      LogGroupName: !Sub /aws/lambda/${UCMetastoreAssignmentFn}
      RetentionInDays: 365

#-------------------------------------------------------------------------
Outputs:

  DatabricksAddressesFnArn:
    Description: The ARN of the CFN function returning the Databricks public addresses
    Value: !GetAtt DatabricksAddressesFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-DatabricksAddressesFn-Arn

  CredentialsConfigurationFnArn:
    Description: The ARN of the CFN function creating a Databricks credentials configuration object
    Value: !GetAtt CredentialsConfigurationFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-CredentialsConfigurationFn-Arn

  StorageConfigurationFnArn:
    Description: The ARN of the CFN function creating a Databricks storage configuration object
    Value: !GetAtt StorageConfigurationFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-StorageConfigurationFn-Arn

  VpcEnpointFnArn:
    Description: The ARN of the CFN function creating a Databricks VPC endpoint
    Value: !GetAtt VpcEnpointFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-VpcEnpointFn-Arn

  PrivateAccessConfigurationFnArn:
    Description: The ARN of the CFN function creating a Databricks private access settings object
    Value: !GetAtt PrivateAccessConfigurationFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-PrivateAccessConfigurationFn-Arn

  NetworkConfigurationFnArn:
    Description: The ARN of the CFN function creating a Databricks network configuration object
    Value: !GetAtt NetworkConfigurationFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-NetworkConfigurationFn-Arn

  ManagedKeysConfigurationFnArn:
    Description: The ARN of the CFN function creating a Databricks managed keys configuration object
    Value: !GetAtt ManagedKeysConfigurationFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-ManagedKeysConfigurationFn-Arn

  WorkspaceFnArn:
    Description: The ARN of the CFN function creating a Databricks workspace
    Value: !GetAtt WorkspaceFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-WorkspaceFn-Arn

  UCMetastoreFnArn:
    Description: The ARN of the CFN function creating a Databricks Unity Catalog metastore
    Value: !GetAtt UCMetastoreFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-UCMetastoreFn-Arn

  UCMetastoreAssignmentFnArn:
    Description: The ARN of the CFN function attaching a Databricks workspace to a Unity Catalog metastore
    Value: !GetAtt UCMetastoreAssignmentFn.Arn
    Export:
      Name: !Sub ${AWS::StackName}-UCMetastoreAssignmentFn-Arn